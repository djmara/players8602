<!DOCTYPE html>
<html>
<head>
    <title>World Cup Players 1986-2002</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            box-sizing: border-box;
        }
        #loading {
            color: white;
            text-align: center;
            font-size: 16px;
        }
        #sketch-container {
            width: 100%;
            max-width: 1920px;
            display: flex;
            justify-content: center;
        }
        canvas {
            max-width: 100%;
            height: auto;
            border: 1px solid #333;
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="loading">Loading player data...</div>
    <div id="sketch-container"></div>
    
    <script>
        // Your complete player data (2339 players from 1986-2002 World Cups)
        let playersData = null;
        
        // Load the data asynchronously
        async function loadPlayerData() {
            try {
                // Read the CSV file and parse it
                const response = await fetch('players.csv');
                const csvText = await response.text();
                
                // Simple CSV parsing for your specific format
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');
                
                playersData = [];
                const targetYears = [1986, 1990, 1994, 1998, 2002];
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = parseCSVLine(line);
                    if (values.length < headers.length) continue;
                    
                    const player = {};
                    headers.forEach((header, index) => {
                        player[header.trim()] = values[index];
                    });
                    
                    // Filter for target years and valid data
                    if (player.given_name && player.family_name && player.birth_date && player.list_tournaments) {
                        if (player.given_name !== "not applicable" && player.family_name !== "not applicable") {
                            const playerYears = player.list_tournaments.toString().split(/[, ]+/)
                                .map(y => parseInt(y.trim()))
                                .filter(y => !isNaN(y) && targetYears.includes(y));
                            
                            if (playerYears.length > 0) {
                                playersData.push({
                                    given_name: player.given_name,
                                    family_name: player.family_name,
                                    birth_date: player.birth_date,
                                    list_tournaments: playerYears.join(", ")
                                });
                            }
                        }
                    }
                }
                
                document.getElementById('loading').style.display = 'none';
                console.log('Loaded', playersData.length, 'players');
                
            } catch (error) {
                console.error('Could not load CSV file, using embedded data instead');
                // Fallback to embedded data if CSV loading fails
                useEmbeddedData();
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result;
        }
        
        function useEmbeddedData() {
            // Embedded sample data in case CSV loading fails
            playersData = [
                {given_name: "Patrice", family_name: "Abanda", birth_date: "1978-08-03", list_tournaments: "1998"},
                {given_name: "Christian", family_name: "Abbiati", birth_date: "1977-07-08", list_tournaments: "2002"},
                {given_name: "Mohamed", family_name: "Abd Al-Jawad", birth_date: "1962-11-28", list_tournaments: "1994"},
                {given_name: "Adel", family_name: "Abdel Rahman", birth_date: "1967-12-11", list_tournaments: "1990"},
                {given_name: "Roberto", family_name: "Baggio", birth_date: "1967-02-18", list_tournaments: "1990, 1994, 1998"},
                {given_name: "Franco", family_name: "Baresi", birth_date: "1960-05-08", list_tournaments: "1986, 1990, 1994"},
                {given_name: "Gabriel", family_name: "Batistuta", birth_date: "1969-02-01", list_tournaments: "1994, 1998, 2002"},
                {given_name: "Dennis", family_name: "Bergkamp", birth_date: "1969-05-10", list_tournaments: "1994, 1998"},
                {given_name: "Oliver", family_name: "Bierhoff", birth_date: "1968-05-01", list_tournaments: "1998"},
                {given_name: "Gianluigi", family_name: "Buffon", birth_date: "1978-01-28", list_tournaments: "1998, 2002"}
            ];
        }

        let marks = [];
        let wcYears = [1986, 1990, 1994, 1998, 2002];
        let currentYearIndex = 0;
        let currentYear = 1986;
        let yearSwitchMillis = 10000;
        let lastSwitchMillis = 0;
        let globalRotation = 0;
        let rotationSpeed = 0.002;
        let yearColors = [];
        let gridColor;
        
        // Responsive scaling variables
        let canvasWidth, canvasHeight;
        let scaleFactor;

        function setup() {
            // Calculate responsive dimensions (80% of original size)
            let baseWidth = 1080 * 0.8;  // 864px
            let baseHeight = 1350 * 0.8; // 1080px
            
            // Make it responsive to screen size
            let maxWidth = min(windowWidth - 40, baseWidth);
            let maxHeight = min(windowHeight - 100, baseHeight);
            
            // Maintain aspect ratio
            let aspectRatio = baseHeight / baseWidth;
            
            if (maxHeight > maxWidth * aspectRatio) {
                canvasWidth = maxWidth;
                canvasHeight = maxWidth * aspectRatio;
            } else {
                canvasHeight = maxHeight;
                canvasWidth = maxHeight / aspectRatio;
            }
            
            // Calculate scale factor for all elements
            scaleFactor = canvasWidth / baseWidth;
            
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('sketch-container');
            
            textFont('Courier New');
            frameRate(60);

            // Initialize colors
            yearColors[0] = color(255, 100, 100);
            yearColors[1] = color(255, 180, 50);
            yearColors[2] = color(100, 200, 100);
            yearColors[3] = color(100, 150, 255);
            yearColors[4] = color(180, 100, 255);
            
            gridColor = color(47, 47, 47);

            currentYear = wcYears[currentYearIndex];
            
            // Load data and start visualization
            loadPlayerData().then(() => {
                loadMarks();
            });
        }
        
        function windowResized() {
            // Recalculate dimensions when window is resized
            let baseWidth = 1080 * 0.8;
            let baseHeight = 1350 * 0.8;
            
            let maxWidth = min(windowWidth - 40, baseWidth);
            let maxHeight = min(windowHeight - 100, baseHeight);
            
            let aspectRatio = baseHeight / baseWidth;
            
            if (maxHeight > maxWidth * aspectRatio) {
                canvasWidth = maxWidth;
                canvasHeight = maxWidth * aspectRatio;
            } else {
                canvasHeight = maxHeight;
                canvasWidth = maxHeight / aspectRatio;
            }
            
            scaleFactor = canvasWidth / baseWidth;
            resizeCanvas(canvasWidth, canvasHeight);
        }

        function draw() {
            // Only draw if data is loaded
            if (!playersData) {
                background(0);
                fill(255);
                textAlign(CENTER, CENTER);
                textSize(16 * scaleFactor);
                text("Loading...", width/2, height/2);
                return;
            }

            // Fade background
            fill(0, 40);
            rect(0, 0, width, height);

            // Year switching logic
            if (millis() - lastSwitchMillis > yearSwitchMillis) {
                currentYearIndex = (currentYearIndex + 1) % wcYears.length;
                currentYear = wcYears[currentYearIndex];
                loadMarks();
                lastSwitchMillis = millis();
            }

            // Dynamic rotation
            let speedMod = 0.001 + 0.0015 * sin(frameCount * 0.01);
            globalRotation += speedMod;

            let centerY = height / 2;
            translate(width/2, centerY);
            rotate(globalRotation);

            drawRadialGrid();

            if (marks.length > 0) {
                let angleStep = TWO_PI / marks.length;
                let hovered = null;

                // Draw player marks with scaled dimensions
                for (let i = 0; i < marks.length; i++) {
                    let pm = marks[i];
                    let angle = i * angleStep;
                    pm.angle = angle;

                    let r = (120 + pm.ringIndex * 40) * scaleFactor;
                    let pulseFreq = 0.02 + 0.01 * (i % 5);
                    let pulseAmp = (15 + (i % 10)) * scaleFactor;
                    let lenBase = map(pm.birthYear, 1940, 2002, 60 * scaleFactor, 200 * scaleFactor);
                    let pulse = pulseAmp * sin(frameCount * pulseFreq + i * 0.1);
                    let len = lenBase + pulse;

                    let x1 = cos(angle) * r;
                    let y1 = sin(angle) * r;
                    let x2 = cos(angle) * (r + len);
                    let y2 = sin(angle) * (r + len);

                    // Mouse interaction
                    let localMouseX = (mouseX - width/2) * cos(-globalRotation) - (mouseY - centerY) * sin(-globalRotation);
                    let localMouseY = (mouseX - width/2) * sin(-globalRotation) + (mouseY - centerY) * cos(-globalRotation);

                    let dx = x2 - x1;
                    let dy = y2 - y1;
                    let lenSq = dx * dx + dy * dy;

                    if (lenSq > 0) {
                        let t = ((localMouseX - x1) * dx + (localMouseY - y1) * dy) / lenSq;
                        t = constrain(t, 0, 1);

                        let projX = x1 + t * dx;
                        let projY = y1 + t * dy;

                        let d = dist(localMouseX, localMouseY, projX, projY);
                        if (d < 8 * scaleFactor) {
                            hovered = pm;
                        }
                    }

                    // Draw line with hover effect
                    let extraLen = 0;
                    if (pm === hovered) {
                        extraLen = 80 * scaleFactor;
                        strokeWeight(1.8 * scaleFactor);
                        stroke(yearColors[pm.ringIndex]);
                    } else {
                        strokeWeight(0.4 * scaleFactor);
                        stroke(red(yearColors[pm.ringIndex]), green(yearColors[pm.ringIndex]), blue(yearColors[pm.ringIndex]), 180);
                    }

                    line(x1, y1, x2 + cos(angle) * extraLen, y2 + sin(angle) * extraLen);
                }

                drawRadialGridSectors();

                // Reset transformation matrix
                resetMatrix();

                drawLegend();

                // Hover label with scaled text
                if (hovered != null) {
                    let mx = mouseX;
                    let my = mouseY;

                    let labelText = hovered.label;
                    textSize(12 * scaleFactor);
                    let tw = textWidth(labelText);
                    let boxW = tw + (20 * scaleFactor);
                    let boxH = 22 * scaleFactor;

                    let offsetX = 15 * scaleFactor;
                    let offsetY = 15 * scaleFactor;

                    fill(0, 220);
                    noStroke();
                    rect(mx + offsetX, my + offsetY, boxW, boxH);

                    fill(255);
                    textAlign(LEFT, CENTER);
                    text(labelText, mx + offsetX + (10 * scaleFactor), my + offsetY + boxH/2);
                }
            }
        }

        function drawRadialGrid() {
            let numCircles = 9;
            let maxR = 500 * scaleFactor;

            noFill();

            for (let i = 0; i <= numCircles; i++) {
                let r = map(i, 0, numCircles, 0, maxR);
                let alpha = map(r, 0, maxR, 255, 0);
                stroke(red(gridColor), green(gridColor), blue(gridColor), alpha);
                strokeWeight(0.4 * scaleFactor);
                ellipse(0, 0, r * 2, r * 2);
            }
        }

        function drawRadialGridSectors() {
            let numRays = 64;
            let maxR = 500 * scaleFactor;

            for (let i = 0; i < numRays; i++) {
                let angle = map(i, 0, numRays, 0, TWO_PI);
                let x1 = 0;
                let y1 = 0;
                let x2 = cos(angle) * maxR;
                let y2 = sin(angle) * maxR;

                stroke(red(gridColor), green(gridColor), blue(gridColor), 180);
                strokeWeight(0.4 * scaleFactor);
                line(x1, y1, x2, y2);
            }
        }

        function drawLegend() {
            let lx = 40 * scaleFactor;
            let ly = 80 * scaleFactor;

            fill(255);
            textAlign(LEFT);
            textSize(12 * scaleFactor);
            text("1986–2002", lx, ly - (24 * scaleFactor));
            text("World Cup", lx, ly - (10 * scaleFactor));
            text("players", lx, ly + (4 * scaleFactor));

            for (let i = 0; i < wcYears.length; i++) {
                let by = ly + (30 * scaleFactor) + i * (22 * scaleFactor);

                stroke(yearColors[i]);
                strokeWeight(0.4 * scaleFactor);
                noFill();
                rect(lx, by, 14 * scaleFactor, 14 * scaleFactor);

                fill(255);
                noStroke();
                textAlign(LEFT, CENTER);
                text(wcYears[i], lx + (20 * scaleFactor), by + (7 * scaleFactor));
            }
        }

        function loadMarks() {
            if (!playersData) return;
            
            marks = [];

            for (let row of playersData) {
                let tournaments = row.list_tournaments;
                let birth = row.birth_date;
                let given = row.given_name;
                let family = row.family_name;

                if (!given || given === "not applicable" || given.trim().length < 1) continue;
                if (!family || family === "not applicable" || family.trim().length < 1) continue;

                if (tournaments && birth && birth.length >= 4) {
                    let birthYear = parseInt(birth.substring(0, 4));
                    let tourYears = tournaments.split(/[, ]+/);

                    for (let ty of tourYears) {
                        let tYear = parseInt(ty.trim());

                        for (let i = 0; i < wcYears.length; i++) {
                            if (tYear === wcYears[i]) {
                                let pm = new PlayerMark(i, birthYear, given + " " + family);
                                marks.push(pm);
                            }
                        }
                    }
                }
            }

            console.log("Marks loaded for year " + currentYear + ":", marks.length);
        }

        class PlayerMark {
            constructor(ri, by, l) {
                this.ringIndex = ri;
                this.birthYear = by;
                this.label = l;
                this.angle = 0;
            }
        }
    </script>
</body>
</html>
